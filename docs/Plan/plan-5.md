I have created the following plan after thorough exploration and analysis of the codebase. Follow the below plan verbatim. Trust the files and references. Do not re-verify what's written in the plan. Explore only when absolutely necessary. First implement all the proposed file changes and then I'll review all the changes together at the end.

### Observations

The codebase already has a solid foundation with security headers and CSP in `next.config.ts`, but they need tightening for production. The current CSP includes `'unsafe-eval'` and `'unsafe-inline'` for scripts, and uses wildcard patterns for Firebase domains. The `SECURITY.md` documents a server-side Admin SDK approach that contradicts the client-only architecture requirement. No Firestore security rules file exists. The service worker is auto-generated by the PWA plugin and caches all API GET requests indiscriminately. Input sanitization is already handled well through React's automatic escaping. Firebase Auth persistence is configured, but strict verification settings are not enabled.

### Approach

Implement defense-in-depth security hardening for the client-centric architecture by: (1) tightening CSP to remove unsafe directives and use strict-dynamic with nonces, (2) adding explicit Firebase domain allowlists, (3) strengthening security headers with stricter policies, (4) creating comprehensive Firestore security rules enforcing per-user access and field validation, (5) configuring custom service worker caching strategy to avoid sensitive data, (6) enabling strict Firebase Auth settings client-side, and (7) completely rewriting SECURITY.md to document client-only security practices without server-side auth references.

### Reasoning

Listed the directory structure to understand the project layout, read the referenced files (`next.config.ts`, `SECURITY.md`, `serviceWorker.tsx`, `lib/firebase.ts`) to assess current security implementation, searched for `dangerouslySetInnerHTML` usage and found only safe CSS injection in chart component, searched for Firestore rules files (none found), examined the auto-generated service worker to understand caching behavior, used context gathering agent to identify all user input handling components, read key files (goals, sessions, export pages) to verify input sanitization practices, and reviewed `AuthProvider.tsx` to check Firebase Auth configuration.

## Mermaid Diagram

sequenceDiagram
    participant User
    participant Browser
    participant NextJS as Next.js App
    participant CSP as Content Security Policy
    participant Firebase as Firebase Client SDK
    participant Firestore as Firestore (with Rules)
    participant SW as Service Worker

    Note over User,SW: Client-Side Security Architecture

    User->>Browser: Access App
    Browser->>NextJS: Request Page
    NextJS->>Browser: Return HTML + Security Headers
    Note over Browser,CSP: CSP: script-src 'self' 'strict-dynamic'<br/>Referrer-Policy: no-referrer<br/>Permissions-Policy: restrictive

    Browser->>CSP: Validate Scripts
    CSP-->>Browser: Allow/Block Scripts

    User->>Browser: Login
    Browser->>Firebase: signInWithEmailAndPassword()
    Firebase-->>Browser: ID Token + User
    Note over Browser,Firebase: Auth persisted in IndexedDB<br/>appVerificationDisabledForTesting=false

    Browser->>Firestore: Query Sessions (with ID Token)
    Firestore->>Firestore: Validate Rules:<br/>request.auth.uid == resource.data.userId
    Firestore-->>Browser: Return User's Sessions Only

    Browser->>SW: Cache Static Assets
    SW->>SW: Cache Strategy:<br/>GET only, no mutations<br/>5min expiration for data
    SW-->>Browser: Serve from Cache (offline)

    User->>Browser: Create Goal (offline)
    Browser->>SW: Queue Mutation
    SW-->>Browser: Queued
    Note over Browser,SW: Mutation queued in IndexedDB

    Browser->>Firestore: Sync Mutation (when online)
    Firestore->>Firestore: Validate Rules + Fields
    Firestore-->>Browser: Success/Reject

    Note over User,SW: Defense-in-Depth Layers:<br/>1. CSP blocks XSS<br/>2. Firestore Rules enforce auth<br/>3. React escapes output<br/>4. SW caches safely<br/>5. No CSRF (no cookies)

## Proposed File Changes

### next.config.ts(MODIFY)

**Tighten Content Security Policy (CSP) for production security:**

1. **Remove unsafe directives from script-src:**
   - Remove `'unsafe-eval'` (only needed for dev HMR, can be conditionally added in dev mode)
   - Remove `'unsafe-inline'` from script-src
   - Add `'strict-dynamic'` to allow scripts loaded by trusted scripts
   - Add nonce support for inline scripts (Next.js supports this via middleware)

2. **Replace wildcard Firebase domains with explicit allowlist:**
   - In `connectSrc`, replace `https://*.googleapis.com` with specific endpoints:
     - `https://firestore.googleapis.com`
     - `https://identitytoolkit.googleapis.com`
     - `https://securetoken.googleapis.com`
   - Replace `https://*.firebaseio.com` with your specific Firebase project domain (e.g., `https://PROJECT_ID.firebaseio.com`)
   - Replace `wss://*.firebaseio.com` with specific WebSocket domain

3. **Update Referrer-Policy header:**
   - Change from `'strict-origin-when-cross-origin'` to `'no-referrer'` for maximum privacy (as specified in requirements)

4. **Add Permissions-Policy header:**
   - Add new header entry to disable unnecessary browser features:
   - `key: 'Permissions-Policy'`
   - `value: 'camera=(), microphone=(), geolocation=(), interest-cohort=()'`
   - This disables camera, microphone, geolocation, and FLoC tracking

5. **Conditional CSP for development:**
   - Modify `generateCSP()` to accept environment parameter
   - Only include `'unsafe-eval'` in script-src when `process.env.NODE_ENV === 'development'`
   - Keep production CSP strict

6. **Add object-src and base-uri restrictions:**
   - Already present, ensure they remain: `'object-src': ["'none'"]`, `'base-uri': ["'self'"]`

Refer to the existing `generateCSP()` function structure and security headers array in `next.config.ts` for implementation context.

### firestore.rules(NEW)

References: 

- types/index.ts
- hooks/useSessionMutations.ts
- hooks/useGoalMutations.ts

**Create comprehensive Firestore security rules for client-only architecture:**

1. **Set rules version and service declaration:**
   - Use `rules_version = '2';`
   - Declare `service cloud.firestore`

2. **Implement strict per-user access control for sessions collection:**
   - Path: `/sessions/{sessionId}`
   - Read rule: `allow read: if request.auth != null && request.auth.uid == resource.data.userId;`
   - Create rule: `allow create: if request.auth != null && request.auth.uid == request.resource.data.userId;`
   - Update rule: `allow update: if request.auth != null && request.auth.uid == resource.data.userId;`
   - Delete rule: `allow delete: if request.auth != null && request.auth.uid == resource.data.userId;`

3. **Implement strict per-user access control for goals collection:**
   - Path: `/goals/{goalId}`
   - Same pattern as sessions: enforce `request.auth.uid == resource.data.userId` for all operations
   - Ensure userId field is immutable on updates: `request.resource.data.userId == resource.data.userId`

4. **Add field-level validation for sessions:**
   - Validate required fields exist: `title`, `userId`, `started_at`, `session_type_id`
   - Validate field types: `request.resource.data.userId is string`, `request.resource.data.total_focus_ms is number`
   - Prevent userId tampering: `request.resource.data.userId == request.auth.uid`
   - Validate timestamps are in ISO format or Firestore Timestamp type

5. **Add field-level validation for goals:**
   - Validate required fields: `title`, `userId`, `type`, `targetValue`, `targetUnit`, `category`
   - Validate enum values: `request.resource.data.type in ['daily', 'weekly', 'monthly']`
   - Validate targetUnit: `request.resource.data.targetUnit in ['hours', 'minutes', 'sessions']`
   - Prevent userId tampering on updates

6. **Add activeSession collection rules (for real-time sync):**
   - Path: `/activeSession/{userId}`
   - Document ID must match authenticated user's UID
   - Read/write only if `request.auth.uid == userId`
   - This supports the `useSyncActiveSession` hook mentioned in `AuthProvider.tsx`

7. **Deny all other collections by default:**
   - Add catch-all rule: `match /{document=**} { allow read, write: if false; }`

Refer to the data structures in `types/index.ts` for field names and the Firestore operations in `hooks/useSessionMutations.ts` and `hooks/useGoalMutations.ts` for access patterns.

### public/sw-custom.js(NEW)

References: 

- lib/firebase.ts(MODIFY)

**Create custom service worker configuration for safe, non-sensitive caching:**

1. **Define cache version and names:**
   - Static cache: `'deepsession-static-v1'`
   - Firebase cache: `'deepsession-firebase-v1'`
   - Use versioning to enable cache busting on updates

2. **Implement static asset caching (cache-first strategy):**
   - Cache Next.js static files: `/_next/static/**`
   - Cache public assets: `/icon-*.png`, `/manifest.json`, fonts
   - Cache CSS and JS bundles
   - Use `CacheFirst` strategy with 30-day expiration

3. **Implement Firebase API caching (network-first with offline fallback):**
   - Match Firebase domains: `https://firestore.googleapis.com/**`, `https://identitytoolkit.googleapis.com/**`, `https://securetoken.googleapis.com/**`
   - **Only cache GET requests** (never cache POST/PUT/DELETE mutations)
   - Use `NetworkFirst` strategy with 10-second timeout
   - Add request method filter: `event.request.method === 'GET'`
   - Set short cache expiration (5 minutes) to avoid stale data

4. **Exclude sensitive endpoints from caching:**
   - Never cache authentication tokens or session cookies
   - Skip caching for paths containing `/auth/`, `/session/`, `/api/`
   - Add explicit cache bypass for mutation operations

5. **Implement cache cleanup on activation:**
   - Delete old cache versions on service worker activation
   - Keep only current version caches

6. **Add runtime caching rules:**
   - Images: `StaleWhileRevalidate` with 30-day expiration
   - Fonts: `CacheFirst` with 1-year expiration
   - HTML pages: `NetworkFirst` with no caching (always fresh)

7. **Add error handling and logging:**
   - Log cache hits/misses in development
   - Gracefully fall back to network on cache errors
   - Return offline page for navigation requests when offline

This replaces the auto-generated service worker from the PWA plugin. Reference the caching patterns in `docs/OFFLINE_TESTING.md` and the Firebase endpoints in `lib/firebase.ts`.

### lib/firebase.ts(MODIFY)

References: 

- context/AuthProvider.tsx

**Enable strict Firebase Auth security settings client-side:**

1. **Add auth verification settings after auth initialization:**
   - After `const auth = getAuth(app);` line (currently line 25)
   - Add conditional check: `if (typeof window !== 'undefined')`
   - Set `auth.settings.appVerificationDisabledForTesting = false`
   - This ensures reCAPTCHA verification is enabled in production

2. **Add comment explaining the security setting:**
   - Document that this prevents automated abuse and bot attacks
   - Note that this is only set on client-side (browser environment)

3. **Verify persistence configuration:**
   - The `initializeFirestore` with `persistentLocalCache` is already correctly configured (lines 37-41)
   - No changes needed here, just verify it remains in place

4. **Add auth state persistence verification:**
   - The persistence is set in `AuthProvider.tsx` using `setPersistence(auth, browserLocalPersistence)`
   - No changes needed in this file for persistence

Refer to the existing Firebase initialization structure and the auth configuration in `context/AuthProvider.tsx` for context.

### docs/SECURITY.md(MODIFY)

References: 

- next.config.ts(MODIFY)
- components/ui/chart.tsx
- app/(authed)/dashboard/layout.tsx

**Completely rewrite SECURITY.md for client-only architecture (remove all server-side references):**

1. **Replace Authentication section:**
   - Remove all references to: session cookies, Admin SDK, middleware verification, server-side session minting
   - Document client-only auth flow:
     - Firebase Client SDK handles all authentication
     - Auth state persisted via `browserLocalPersistence` in IndexedDB
     - No server-side session cookies or tokens
     - Email verification enforced client-side before dashboard access
   - Document auth guards:
     - Client-side route protection in `(authed)/dashboard/layout.tsx` using `useAuth` hook
     - Redirects handled via `useRouter` and `useEffect`
     - Unauthenticated users → `/login`, unverified → `/verify-email`

2. **Replace Authorization section:**
   - Remove role-based access and custom claims (server-side concepts)
   - Document Firestore security rules as the authorization layer:
     - All access control enforced via Firestore rules
     - Per-user data isolation: `request.auth.uid == resource.data.userId`
     - No server-side authorization checks

3. **Update Data Protection section:**
   - Document Firestore rules as primary security mechanism (reference `firestore.rules`)
   - Explain offline-first data access:
     - Client SDK reads from IndexedDB cache when offline
     - Mutations queued and synced when online
     - No server-side data fetching or Admin SDK bypass
   - Document field-level validation in Firestore rules

4. **Replace Monitoring section:**
   - Remove audit logging, token revocation, server-side monitoring
   - Document client-side security practices:
     - Firebase Auth automatically handles suspicious activity detection
     - Client-side error logging for security events (failed auth, rule violations)
     - No server-side audit logs needed

5. **Add new Content Security Policy (CSP) section:**
   - Document the strict CSP configuration in `next.config.ts`:
     - `script-src 'self' 'strict-dynamic'` (no unsafe-eval/inline in production)
     - Explicit Firebase domain allowlist in `connect-src`
     - `object-src 'none'` to block plugins
   - Explain nonce-based inline script security

6. **Add new Input Sanitization section:**
   - Document that React automatically escapes all output
   - Note the single `dangerouslySetInnerHTML` usage in `components/ui/chart.tsx` is safe (CSS only, no user input)
   - Best practices:
     - Always use controlled components for forms
     - Never use `dangerouslySetInnerHTML` with user data
     - Trust React's automatic escaping

7. **Add new Service Worker Security section:**
   - Document custom service worker caching strategy (reference `public/sw-custom.js`):
     - Only caches GET requests (never mutations)
     - Short cache expiration for Firebase data (5 minutes)
     - Static assets cached with longer expiration
     - Sensitive endpoints excluded from cache

8. **Add new Security Headers section:**
   - Document all headers configured in `next.config.ts`:
     - `X-Content-Type-Options: nosniff`
     - `Referrer-Policy: no-referrer`
     - `X-Frame-Options: SAMEORIGIN`
     - `Permissions-Policy` (camera, microphone, geolocation disabled)
     - `Strict-Transport-Security` (HSTS)

9. **Update Operational Hygiene section:**
   - Remove service account key management (not applicable)
   - Document Firebase project configuration:
     - API keys stored in `.env.local` (not committed)
     - Separate Firebase projects for dev/staging/production
     - Firebase Auth domain restrictions configured
   - Document dependency management:
     - Keep Firebase Client SDK updated
     - Regular security audits with `npm audit`

10. **Add CSRF Protection note:**
    - Explain that CSRF is largely eliminated with client-only auth:
      - No cookies used for authentication
      - Firebase ID tokens in Authorization headers not automatically sent
      - Firestore rules enforce user identity on all operations

11. **Add Testing Checklist section:**
    - Offline mode testing (reference `docs/OFFLINE_TESTING.md`)
    - Firestore rules testing with Firebase Emulator
    - CSP violation monitoring in browser console
    - Auth flow testing (signup, login, email verification, logout)

Remove all references to: Admin SDK, server routes, session cookies, middleware auth verification, audit logging, token revocation, role-based access. Focus entirely on client-side security mechanisms.

### docs/CLIENT_SECURITY_PRACTICES.md(NEW)

References: 

- app/(authed)/dashboard/goals/page.tsx
- context/AuthProvider.tsx

**Create comprehensive guide for client-side security best practices:**

1. **Introduction section:**
   - Explain DeepSession v3's client-only architecture philosophy
   - Benefits: offline-first, no server complexity, reduced attack surface
   - Security model: defense-in-depth with multiple layers

2. **Input Handling Best Practices:**
   - Always use React controlled components for forms
   - Never use `dangerouslySetInnerHTML` with user-generated content
   - Trust React's automatic XSS protection via escaping
   - Validate input on client-side for UX, but rely on Firestore rules for security
   - Examples from codebase:
     - Good: `<Input value={title} onChange={(e) => setTitle(e.target.value)} />` (from `app/(authed)/dashboard/goals/page.tsx`)
     - Bad: `<div dangerouslySetInnerHTML={{__html: userInput}} />` (never do this)

3. **Firestore Security Rules as Authorization Layer:**
   - Explain that Firestore rules are the primary security boundary
   - Rules enforce:
     - Authentication requirement (`request.auth != null`)
     - User ownership (`request.auth.uid == resource.data.userId`)
     - Field-level validation (types, enums, required fields)
     - Immutable fields (userId cannot be changed)
   - Testing rules with Firebase Emulator before deployment
   - Reference the `firestore.rules` file for implementation

4. **Authentication Security:**
   - Firebase Client SDK handles all auth operations
   - Auth state persisted in IndexedDB (survives page refresh, offline-capable)
   - Email verification enforced before dashboard access
   - Client-side route guards in layout components
   - No server-side session cookies = no CSRF risk
   - reCAPTCHA verification enabled (`appVerificationDisabledForTesting = false`)

5. **Content Security Policy (CSP) Hardening:**
   - Explain the strict CSP configuration
   - Why `'unsafe-eval'` and `'unsafe-inline'` are removed in production
   - How `'strict-dynamic'` works with nonces
   - Explicit Firebase domain allowlist prevents data exfiltration
   - Monitoring CSP violations in browser console

6. **Service Worker Caching Strategy:**
   - Only cache GET requests (mutations never cached)
   - Short expiration for user data (5 minutes)
   - Long expiration for static assets (30 days)
   - Sensitive endpoints excluded from cache
   - Cache versioning for updates

7. **Offline Security Considerations:**
   - Data cached in IndexedDB is encrypted at rest by browser
   - Mutations queued offline are validated by Firestore rules when synced
   - Auth tokens refresh automatically when online
   - Stale data risks mitigated by short cache expiration

8. **Dependency Security:**
   - Keep Firebase SDK updated for security patches
   - Regular `npm audit` and `pnpm audit` runs
   - Review shadcn/ui component updates for vulnerabilities
   - Pin major versions to avoid breaking changes

9. **Environment Variable Security:**
   - Firebase API keys in `.env.local` (not committed to git)
   - API keys are public-facing but protected by Firebase domain restrictions
   - Separate Firebase projects for dev/staging/production
   - Never commit service account keys (not used in client-only architecture)

10. **Common Pitfalls to Avoid:**
    - Don't store sensitive data in localStorage (use Firestore with rules)
    - Don't trust client-side validation alone (enforce in Firestore rules)
    - Don't disable CSP for convenience (fix violations instead)
    - Don't cache authenticated API responses indefinitely
    - Don't use `eval()` or `Function()` constructor with user input

11. **Security Testing Checklist:**
    - Test Firestore rules with Firebase Emulator
    - Verify CSP violations in browser console
    - Test offline mode with DevTools Network throttling
    - Verify email verification enforcement
    - Test auth state persistence across page refreshes
    - Check service worker caching behavior in DevTools Application tab

12. **Incident Response:**
    - Monitor Firebase Auth for suspicious login attempts
    - Review Firestore rules violations in Firebase Console
    - Update dependencies immediately on security advisories
    - Rotate Firebase API keys if compromised (via Firebase Console)

Include code examples from the codebase (goals page, session tracker, auth provider) to illustrate best practices.

### middleware.ts(NEW)

References: 

- next.config.ts(MODIFY)

**Create minimal middleware for CSP nonce injection (optional but recommended):**

1. **Import Next.js middleware utilities:**
   - Import `NextResponse` from `next/server`
   - Import `NextRequest` from `next/server`

2. **Generate CSP nonce:**
   - Use `crypto.randomUUID()` or similar to generate a unique nonce per request
   - This nonce will be used in CSP header and injected into inline scripts

3. **Add CSP header with nonce:**
   - Clone the response headers
   - Add or update the `Content-Security-Policy` header
   - Include the nonce in `script-src`: `script-src 'self' 'nonce-{NONCE}' 'strict-dynamic'`
   - This allows Next.js inline scripts while blocking unauthorized scripts

4. **Configure matcher:**
   - Match all routes: `matcher: '/:path*'`
   - Or exclude static assets: `matcher: ['/((?!_next/static|_next/image|favicon.ico).*)']`

5. **Pass nonce to pages (optional):**
   - Store nonce in request headers for access in pages
   - Next.js can read this in Server Components if needed

6. **Keep middleware lightweight:**
   - No auth verification (handled client-side)
   - No database queries
   - Only CSP nonce generation and header injection
   - Fast execution to avoid latency

**Note:** This is optional. If CSP nonce injection is too complex, you can keep the static CSP from `next.config.ts` and accept that some Next.js inline scripts may require `'unsafe-inline'` in development. For production, Next.js can work with `'strict-dynamic'` alone if properly configured.

Refer to Next.js middleware documentation and the CSP configuration in `next.config.ts` for context.

### docs/FIRESTORE_RULES_TESTING.md(NEW)

References: 

- lib/firebase.ts(MODIFY)

**Create guide for testing Firestore security rules locally:**

1. **Introduction:**
   - Explain importance of testing rules before deployment
   - Firebase Emulator Suite allows local testing without affecting production

2. **Setup Firebase Emulator:**
   - Install Firebase CLI: `npm install -g firebase-tools`
   - Initialize emulators: `firebase init emulators`
   - Select Firestore and Authentication emulators
   - Configure ports (default: Firestore 8080, Auth 9099)

3. **Configure emulator in project:**
   - Create `firebase.json` with emulator configuration
   - Update `lib/firebase.ts` to connect to emulator in development:
     ```typescript
     if (process.env.NODE_ENV === 'development') {
       connectFirestoreEmulator(db, 'localhost', 8080);
       connectAuthEmulator(auth, 'http://localhost:9099');
     }
     ```

4. **Write test cases for sessions collection:**
   - Test authenticated user can read their own sessions
   - Test authenticated user cannot read other users' sessions
   - Test authenticated user can create session with their userId
   - Test authenticated user cannot create session with different userId
   - Test authenticated user can update their own session
   - Test authenticated user cannot update other users' sessions
   - Test unauthenticated user cannot read/write any sessions

5. **Write test cases for goals collection:**
   - Same pattern as sessions: test read/write permissions
   - Test field validation: type enum, targetUnit enum
   - Test userId immutability on updates

6. **Write test cases for activeSession collection:**
   - Test user can only access document with their UID as document ID
   - Test user cannot access other users' active sessions

7. **Run tests:**
   - Start emulator: `firebase emulators:start`
   - Run test suite: `npm test` or `pnpm test`
   - View emulator UI: `http://localhost:4000`

8. **Common test scenarios:**
   - Unauthorized access attempts
   - Field tampering (changing userId)
   - Invalid data types
   - Missing required fields
   - Enum validation

9. **Deploy rules after testing:**
   - Deploy to production: `firebase deploy --only firestore:rules`
   - Verify in Firebase Console

10. **Continuous testing:**
    - Add rules testing to CI/CD pipeline
    - Run tests before every deployment
    - Monitor Firestore rules violations in Firebase Console

Include example test code using Firebase Testing SDK and reference the rules in `firestore.rules`.